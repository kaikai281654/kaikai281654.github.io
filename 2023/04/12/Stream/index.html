
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>JavaBaseStream | 小凯的博客</title>
        <meta name="author" content="John Doe" />
        <meta name="description" content="感兴趣什么自己就学点什么吧" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div id="layout">
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>小凯的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;小凯的博客</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>JavaBaseStream</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/12
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>文章目录<br>•IO概述<br>•<br>•什么是IO<br>•IO的分类<br>•IO的流向说明图解<br>•顶级父类们<br>•字节流<br>•<br>•一切皆为字节<br>•字节输出流【OutputStream】<br>•FileOutputStream类<br>•<br>•构造方法<br>•写出字节数据<br>•数据追加续写<br>•写出换行<br>•字节输入流【InputStream】<br>•FileInputStream类<br>•<br>•构造方法<br>•读取字节数据<br>•字节流练习：图片复制<br>•<br>•复制原理图解<br>•案例实现<br>•字符流<br>•<br>•字符输入流【Reader】<br>•FileReader类<br>•<br>•构造方法<br>•读取字符数据<br>•字符输出流【Writer】<br>•FileWriter类<br>•<br>•构造方法<br>•基本写出数据<br>•关闭和刷新<br>•写出其他数据<br>•IO异常的处理<br>•<br>•<br>•JDK7前处理<br>•JDK7的处理(扩展知识点了解内容)<br>•JDK9的改进(扩展知识点了解内容)<br>•属性集<br>•<br>•概述<br>•Properties类<br>•<br>•构造方法<br>•基本的存储方法<br>•与流相关的方法</p>
<p>IO概述<br>什么是IO<br>生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了ctrl+s ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。<br>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。<br>Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。</p>
<p>IO的分类<br>根据数据的流向分为：输入流和输出流。</p>
<p>•输入流 ：把数据从其他设备上读取到内存中的流。<br>•输出流 ：把数据从内存 中写出到其他设备上的流。</p>
<p>格局数据的类型分为：字节流和字符流。</p>
<p>•字节流 ：以字节为单位，读写数据的流。<br>•字符流 ：以字符为单位，读写数据的流。</p>
<p>IO的流向说明图解<br>在这里插入图片描述<br>在这里插入图片描述<br>顶级父类们<br>输入流    输出流<br>字节流    字节输入流InputStream    字节输出流OutputStream<br>字符流    字符输入流Reader    字符输出流Writer<br>字节流<br>一切皆为字节<br>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p>
<p>字节输出流【OutputStream】<br>java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p>•public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。<br>•public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。<br>•public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。<br>•public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。<br>•public abstract void write(int b) ：将指定的字节输出流。</p>
<p>💡小贴士：<br>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
<p>FileOutputStream类<br>OutputStream有很多子类，我们从最简单的一个子类开始。<br>java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。</p>
<p>构造方法<br>•public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。<br>•public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。</p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p>
<p>•构造举例，代码如下：</p>
<p>public class FileOutputStreamConstructor throws IOException {<br>    public static void main(String[] args) {<br>            File file = new File(“D:\zjq\IOAndProperties\a.txt”);<br>        if(file.exists()){<br>            //file.mkdir();<br>            file.createNewFile();<br>        }<br>        //1.创建一个FileOutputStream对象,构造方法中传递写入数据的目的地<br>        FileOutputStream fos = new FileOutputStream(file);<br>        //2.调用FileOutputStream对象中的方法write,把数据写入到文件中<br>        //public abstract void write(int b) ：将指定的字节输出流。<br>        fos.write(97);<br>        //3.释放资源(流使用会占用一定的内存,使用完毕要把内存清空,提供程序的效率)<br>        fos.close();<br>    }<br>}<br>写出字节数据<br>1.写出字节：write(int b) 方法，每次可以写出一个字节数据，代码使用演示：</p>
<p>public class FOSWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileOutputStream fos = new FileOutputStream(“fos.txt”);<br>          // 写出数据<br>          fos.write(97); // 写出第1个字节<br>          fos.write(98); // 写出第2个字节<br>          fos.write(99); // 写出第3个字节<br>          // 关闭资源<br>        fos.close();<br>    }<br>}<br>输出结果：<br>abc<br>📌小贴士：</p>
<p>1.虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。<br>2.流操作完毕后，必须释放系统资源，调用close方法，千万记得。</p>
<p>1.写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示：</p>
<p>public class FOSWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileOutputStream fos = new FileOutputStream(“fos.txt”);<br>          // 字符串转换为字节数组<br>          byte[] b = “zjq666”.getBytes();<br>          // 写出字节数组数据<br>          fos.write(b);<br>          // 关闭资源<br>        fos.close();<br>    }<br>}<br>1.写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码使用演示：</p>
<p>public class FOSWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileOutputStream fos = new FileOutputStream(“fos.txt”);<br>          // 字符串转换为字节数组<br>          byte[] b = “abcde”.getBytes();<br>        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。<br>        fos.write(b,2,2);<br>          // 关闭资源<br>        fos.close();<br>    }<br>}<br>输出结果：<br>cd<br>数据追加续写<br>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p>
<p>•public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。<br>•public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。</p>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p>
<p>public class FOSWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileOutputStream fos = new FileOutputStream(“fos.txt”，true);<br>          // 字符串转换为字节数组<br>          byte[] b = “abcde”.getBytes();<br>        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。<br>        fos.write(b);<br>          // 关闭资源<br>        fos.close();<br>    }<br>}<br>文件操作前：cd<br>文件操作后：cdabcde<br>写出换行<br>Windows系统里，换行符号是\r\n 。把<br>以指定是否追加续写了，代码使用演示：</p>
<p>public class FOSWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileOutputStream fos = new FileOutputStream(“fos.txt”);<br>          // 定义字节数组<br>          byte[] words = {97,98,99,100,101};<br>          // 遍历数组<br>        for (int i = 0; i &lt; words.length; i++) {<br>              // 写出一个字节<br>            fos.write(words[i]);<br>              // 写出一个换行, 换行符号转成数组写出<br>            fos.write(“\r\n”.getBytes());<br>        }<br>          // 关闭资源<br>        fos.close();<br>    }<br>}</p>
<p>输出结果：<br>a<br>b<br>c<br>d<br>e<br>•回车符\r和换行符\n ：<br>•回车符：回到一行的开头（return）。<br>•换行符：下一行（newline）。</p>
<p>•系统中的换行：<br>•Windows系统里，每行结尾是 回车+换行 ，即\r\n；<br>•Unix系统里，每行结尾只有 换行 ，即\n；<br>•Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。</p>
<p>字节输入流【InputStream】<br>java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<p>•public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。<br>•public abstract int read()： 从输入流读取数据的下一个字节。<br>•public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<p>📌小贴士：<br>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
<p>FileInputStream类<br>java.io.FileInputStream类是文件输入流，从文件中读取字节。</p>
<p>构造方法<br>•FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br>•FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。</p>
<p>•构造举例，代码如下：</p>
<p>public class FileInputStreamConstructor throws IOException{<br>    public static void main(String[] args) {<br>            // 使用File对象创建流对象<br>        File file = new File(“a.txt”);<br>        FileInputStream fos = new FileInputStream(file);</p>
<pre><code>    // 使用文件名称创建流对象
    FileInputStream fos = new FileInputStream(&quot;b.txt&quot;);
&#125;
</code></pre>
<p>}<br>读取字节数据<br>1.读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码使用演示：</p>
<p>public class FISRead {<br>    public static void main(String[] args) throws IOException{<br>          // 使用文件名称创建流对象<br>           FileInputStream fis = new FileInputStream(“read.txt”);<br>          // 读取数据，返回一个字节<br>        int read = fis.read();<br>        System.out.println((char) read);<br>        read = fis.read();<br>        System.out.println((char) read);<br>        read = fis.read();<br>        System.out.println((char) read);<br>        read = fis.read();<br>        System.out.println((char) read);<br>        read = fis.read();<br>        System.out.println((char) read);<br>          // 读取到末尾,返回-1<br>           read = fis.read();<br>        System.out.println( read);<br>        // 关闭资源<br>        fis.close();<br>    }<br>}<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br>-1<br>循环改进读取方式，代码使用演示：</p>
<p>public class FISRead {<br>    public static void main(String[] args) throws IOException{<br>          // 使用文件名称创建流对象<br>           FileInputStream fis = new FileInputStream(“read.txt”);<br>          // 定义变量，保存数据<br>        int b ；<br>        // 循环读取<br>        while ((b = fis.read())!=-1) {<br>            System.out.println((char)b);<br>        }<br>        // 关闭资源<br>        fis.close();<br>    }<br>}<br>输出结果：<br>a<br>b<br>c<br>d<br>e<br>📌小贴士：</p>
<p>1.虽然读取了一个字节，但是会自动提升为int类型。<br>2.流操作完毕后，必须释放系统资源，调用close方法，千万记得。</p>
<p>1.使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示：</p>
<p>public class FISRead {<br>    public static void main(String[] args) throws IOException{<br>          // 使用文件名称创建流对象.<br>           FileInputStream fis = new FileInputStream(“read.txt”); // 文件中为abcde<br>          // 定义变量，作为有效个数<br>        int len ；<br>        // 定义字节数组，作为装字节数据的容器<br>        byte[] b = new byte[2];<br>        // 循环读取<br>        while (( len= fis.read(b))!=-1) {<br>               // 每次读取后,把数组变成字符串打印<br>            System.out.println(new String(b));<br>        }<br>        // 关闭资源<br>        fis.close();<br>    }<br>}</p>
<p>输出结果：<br>ab<br>cd<br>ed<br>错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示：</p>
<p>public class FISRead {<br>    public static void main(String[] args) throws IOException{<br>          // 使用文件名称创建流对象.<br>           FileInputStream fis = new FileInputStream(“read.txt”); // 文件中为abcde<br>          // 定义变量，作为有效个数<br>        int len ；<br>        // 定义字节数组，作为装字节数据的容器<br>        byte[] b = new byte[2];<br>        // 循环读取<br>        while (( len= fis.read(b))!=-1) {<br>               // 每次读取后,把数组的有效字节部分，变成字符串打印<br>            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数<br>        }<br>        // 关闭资源<br>        fis.close();<br>    }<br>}</p>
<p>输出结果：<br>ab<br>cd<br>e<br>📌小贴士：<br>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
<p>字节流练习：图片复制<br>复制原理图解<br>在这里插入图片描述<br>在这里插入图片描述<br>案例实现<br>复制图片文件，代码使用演示：</p>
<p>public class Copy {<br>    public static void main(String[] args) throws IOException {<br>        // 1.创建流对象<br>        // 1.1 指定数据源<br>        FileInputStream fis = new FileInputStream(“D:\test.jpg”);<br>        // 1.2 指定目的地<br>        FileOutputStream fos = new FileOutputStream(“test_copy.jpg”);</p>
<pre><code>    // 2.读写数据
    // 2.1 定义数组
    byte[] b = new byte[1024];
    // 2.2 定义长度
    int len;
    // 2.3 循环读取
    while ((len = fis.read(b))!=-1) &#123;
        // 2.4 写出数据
        fos.write(b, 0 , len);
    &#125;

    // 3.关闭资源
    fos.close();
    fis.close();
&#125;
</code></pre>
<p>}<br>📌小贴士：<br>流的关闭原则：先开后关，后开先关。</p>
<p>字符流<br>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<p>字符输入流【Reader】<br>java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p>•public void close() ：关闭此流并释放与此流相关联的任何系统资源。<br>•public int read()： 从输入流读取一个字符。<br>•public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</p>
<p>FileReader类<br>java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p>📌小贴士：</p>
<p>1.字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。<br>idea中UTF-8<br>2.字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
<p>构造方法<br>•FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。<br>•FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。</p>
<p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p>
<p>•构造举例，代码如下：</p>
<p>public class FileReaderConstructor throws IOException{<br>    public static void main(String[] args) {<br>            // 使用File对象创建流对象<br>        File file = new File(“a.txt”);<br>        FileReader fr = new FileReader(file);</p>
<pre><code>    // 使用文件名称创建流对象
    FileReader fr = new FileReader(&quot;b.txt&quot;);
&#125;
</code></pre>
<p>}<br>读取字符数据<br>1.读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示：</p>
<p>public class FRRead {<br>    public static void main(String[] args) throws IOException {<br>          // 使用文件名称创建流对象<br>           FileReader fr = new FileReader(“read.txt”);<br>          // 定义变量，保存数据<br>        int b ；<br>        // 循环读取<br>        while ((b = fr.read())!=-1) {<br>            System.out.println((char)b);<br>        }<br>        // 关闭资源<br>        fr.close();<br>    }<br>}<br>📌小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
<p>1.使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 ，代码使用演示：</p>
<p>public class FRRead {<br>    public static void main(String[] args) throws IOException {<br>          // 使用文件名称创建流对象<br>           FileReader fr = new FileReader(“read.txt”);<br>          // 定义变量，保存有效字符个数<br>        int len ；<br>        // 定义字符数组，作为装字符数据的容器<br>         char[] cbuf = new char[2];<br>        // 循环读取<br>        while ((len = fr.read(cbuf))!=-1) {<br>            System.out.println(new String(cbuf));<br>        }<br>        // 关闭资源<br>        fr.close();<br>    }<br>}</p>
<p>输出结果：<br>天下<br>第一<br>刀一<br>获取有效的字符改进，代码使用演示：</p>
<p>public class FISRead {<br>    public static void main(String[] args) throws IOException {<br>          // 使用文件名称创建流对象<br>           FileReader fr = new FileReader(“read.txt”);<br>          // 定义变量，保存有效字符个数<br>        int len ；<br>        // 定义字符数组，作为装字符数据的容器<br>        char[] cbuf = new char[2];<br>        // 循环读取<br>        while ((len = fr.read(cbuf))!=-1) {<br>            System.out.println(new String(cbuf,0,len));<br>        }<br>        // 关闭资源<br>        fr.close();<br>    }<br>}</p>
<p>输出结果：<br>天下<br>第一<br>刀<br>字符输出流【Writer】<br>java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p>•void write(int c) 写入单个字符。<br>•void write(char[] cbuf)写入字符数组。<br>•abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。<br>•void write(String str)写入字符串。<br>•void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。<br>•void flush()刷新该流的缓冲。<br>•void close() 关闭此流，但要先刷新它。</p>
<p>FileWriter类<br>java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p>构造方法<br>•FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。<br>•FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。</p>
<p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p>
<p>•构造举例，代码如下：</p>
<p>public class FileWriterConstructor {<br>    public static void main(String[] args) throws IOException {<br>            // 使用File对象创建流对象<br>        File file = new File(“a.txt”);<br>        FileWriter fw = new FileWriter(file);</p>
<pre><code>    // 使用文件名称创建流对象
    FileWriter fw = new FileWriter(&quot;b.txt&quot;);
&#125;
</code></pre>
<p>}<br>基本写出数据<br>写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示：</p>
<p>public class FWWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileWriter fw = new FileWriter(“fw.txt”);<br>          // 写出数据<br>          fw.write(97); // 写出第1个字符<br>          fw.write(‘b’); // 写出第2个字符<br>          fw.write(‘C’); // 写出第3个字符<br>          fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。</p>
<pre><code>      /*
    【注意】关闭资源时,与FileOutputStream不同。
       如果不关闭,数据只是保存到缓冲区，并未保存到文件。
    */
    // fw.close();
&#125;
</code></pre>
<p>}<br>输出结果：<br>abC田<br>📌小贴士：</p>
<p>1.虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。<br>2.未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</p>
<p>关闭和刷新<br>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。</p>
<p>•flush ：刷新缓冲区，流对象可以继续使用。<br>•close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</p>
<p>代码使用演示：</p>
<p>public class FWWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileWriter fw = new FileWriter(“fw.txt”);<br>        // 写出数据，通过flush<br>        fw.write(‘刷’); // 写出第1个字符<br>        fw.flush();<br>        fw.write(‘新’); // 继续写出第2个字符，写出成功<br>        fw.flush();</p>
<pre><code>      // 写出数据，通过close
    fw.write(&#39;关&#39;); // 写出第1个字符
    fw.close();
    fw.write(&#39;闭&#39;); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed
    fw.close();
&#125;
</code></pre>
<p>}<br>📌小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
<p>写出其他数据<br>1.写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</p>
<p>public class FWWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileWriter fw = new FileWriter(“fw.txt”);<br>          // 字符串转换为字节数组<br>          char[] chars = “归海一刀”.toCharArray();</p>
<pre><code>      // 写出字符数组
      fw.write(chars); // 归海一刀
    
    // 写出从索引2开始，2个字节。索引2是&#39;一&#39;，两个字节，也就是&#39;一刀&#39;。
    fw.write(b,2,2); // 程序
  
      // 关闭资源
    fos.close();
&#125;
</code></pre>
<p>}<br>1.写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示：</p>
<p>public class FWWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象<br>        FileWriter fw = new FileWriter(“fw.txt”);<br>          // 字符串<br>          String msg = “归海一刀”;</p>
<pre><code>      // 写出字符数组
      fw.write(msg); //归海一刀
  
    // 写出从索引2开始，2个字节。索引2是&#39;一&#39;，两个字节，也就是&#39;一刀&#39;。
    fw.write(msg,2,2);    // 一刀
      
    // 关闭资源
    fos.close();
&#125;
</code></pre>
<p>}<br>1.续写和换行：操作类似于FileOutputStream。</p>
<p>public class FWWrite {<br>    public static void main(String[] args) throws IOException {<br>        // 使用文件名称创建流对象，可以续写数据<br>        FileWriter fw = new FileWriter(“fw.txt”，true);<br>          // 写出字符串<br>        fw.write(“三分”);<br>          // 写出换行<br>          fw.write(“\r\n”);<br>          // 写出字符串<br>          fw.write(“归元气”);<br>          // 关闭资源<br>        fw.close();<br>    }<br>}<br>输出结果:<br>三分<br>归元气<br>📌小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。<br>当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流</p>
<p>IO异常的处理<br>JDK7前处理<br>之前的练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try…catch…finally 代码块，处理异常部分，代码使用演示：</p>
<p>public class HandleException1 {<br>    public static void main(String[] args) {<br>          // 声明变量<br>        FileWriter fw = null;<br>        try {<br>            //创建流对象<br>            fw = new FileWriter(“fw.txt”);<br>            // 写出数据<br>            fw.write(“三分归元气”); //三分归元气<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        } finally {<br>            try {<br>                if (fw != null) {<br>                    fw.close();<br>                }<br>            } catch (IOException e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}<br>JDK7的处理(扩展知识点了解内容)<br>还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。<br>格式：</p>
<p>try (创建流对象语句，如果多个,使用’;’隔开) {<br>    // 读写数据<br>} catch (IOException e) {<br>    e.printStackTrace();<br>}<br>代码使用演示：</p>
<p>public class HandleException2 {<br>    public static void main(String[] args) {<br>          // 创建流对象<br>        try ( FileWriter fw = new FileWriter(“fw.txt”); ) {<br>            // 写出数据<br>            fw.write(“三分归元气”); //三分归元气<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>JDK9的改进(扩展知识点了解内容)<br>JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。<br>改进前格式：</p>
<p>// 被final修饰的对象<br>final Resource resource1 = new Resource(“resource1”);<br>// 普通对象<br>Resource resource2 = new Resource(“resource2”);<br>// 引入方式：创建新的变量保存<br>try (Resource r1 = resource1;<br>     Resource r2 = resource2) {<br>     // 使用对象<br>}<br>改进后格式：</p>
<p>// 被final修饰的对象<br>final Resource resource1 = new Resource(“resource1”);<br>// 普通对象<br>Resource resource2 = new Resource(“resource2”);</p>
<p>// 引入方式：直接引入<br>try (resource1; resource2) {<br>     // 使用对象<br>}<br>改进后，代码使用演示：</p>
<p>public class TryDemo {<br>    public static void main(String[] args) throws IOException {<br>           // 创建流对象<br>        final  FileReader fr  = new FileReader(“in.txt”);<br>        FileWriter fw = new FileWriter(“out.txt”);<br>           // 引入到try中<br>        try (fr; fw) {<br>              // 定义变量<br>            int b;<br>              // 读取数据<br>              while ((b = fr.read())!=-1) {<br>                // 写出数据<br>                fw.write(b);<br>              }<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>    }<br>}<br>属性集<br>概述<br>java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。</p>
<p>Properties类<br>构造方法<br>•public Properties() :创建一个空的属性列表。</p>
<p>基本的存储方法<br>•public Object setProperty(String key, String value) ： 保存一对属性。<br>•public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。<br>•public Set<String> stringPropertyNames() ：所有键的名称的集合。</p>
<p>public class ProDemo {<br>    public static void main(String[] args) throws FileNotFoundException {<br>        // 创建属性集对象<br>        Properties properties = new Properties();<br>        // 添加键值对元素<br>        properties.setProperty(“filename”, “a.txt”);<br>        properties.setProperty(“length”, “209385038”);<br>        properties.setProperty(“location”, “D:\a.txt”);<br>        // 打印属性集对象<br>        System.out.println(properties);<br>        // 通过键,获取属性值<br>        System.out.println(properties.getProperty(“filename”));<br>        System.out.println(properties.getProperty(“length”));<br>        System.out.println(properties.getProperty(“location”));</p>
<pre><code>    // 遍历属性集,获取所有键的集合
    Set&lt;String&gt; strings = properties.stringPropertyNames();
    // 打印键值对
    for (String key : strings ) &#123;
          System.out.println(key+&quot; -- &quot;+properties.getProperty(key));
    &#125;
&#125;
</code></pre>
<p>}<br>输出结果：<br>{filename=a.txt, length=209385038, location=D:\a.txt}<br>a.txt<br>209385038<br>D:\a.txt<br>filename – a.txt<br>length – 209385038<br>location – D:\a.txt<br>与流相关的方法<br>•public void load(InputStream inStream)： 从字节输入流中读取键值对。</p>
<p>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:</p>
<p>filename=a.txt<br>length=209385038<br>location=D:\a.txt<br>加载代码演示：</p>
<p>public class ProDemo2 {<br>    public static void main(String[] args) throws FileNotFoundException {<br>        // 创建属性集对象<br>        Properties pro = new Properties();<br>        // 加载文本中信息到属性集<br>        pro.load(new FileInputStream(“read.txt”));<br>        // 遍历集合并打印<br>        Set<String> strings = pro.stringPropertyNames();<br>        for (String key : strings ) {<br>              System.out.println(key+” – “+pro.getProperty(key));<br>        }<br>     }<br>}<br>输出结果：<br>filename – a.txt<br>length – 209385038<br>location – D:\a.txt<br>📌小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>

    </div>
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 小凯的博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;John Doe
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            </transition>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
